package com.datastructure.sort;

/**
 * @Author: BryantCong
 * @Date: 2019/12/10 17:59
 * @Description: 堆排序
 * <p>
 * 堆是完全二叉树
 * 父节点大于子节点（大顶堆）
 * 父节点小于子节点（小顶堆）
 * <p>
 * 堆排序的关键就是构造初始堆。
 * n个结点的完全二叉树中，最后一个结点是第n/2（向下取整）个结点的孩子。
 * 所以构造初始堆的流程是：对第n/2（向下取整）个结点为根的子树进行筛选（以大根堆为例，若根结点的关键字小于左右子女中关键字的较大者，则交换），使该子树成为堆。
 * 之后向前依次对从n/2-1到1的各结点为根的子树进行筛选，看该结点值是否大于其左右子结点的值，若不是，将左右子结点中较大值与之交换，交换后可能会破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到以该结点为根的子树构成堆为止。反复利用上述调整堆的方法建堆，直到根结点
 * 注意  从最后一个非叶子节点往前，依次将这些非叶子节点构成的子树进行调整，使其成为堆
 * 在调整的过程中可能会导致该子树下面的更深层次的子树不符合堆，于是需要重新将被破坏的子树调整为堆。
 * <p>
 * 这样就成功构造了初始堆
 * 之后，将堆低元素和堆顶元素互换，这时候，就会导致
 * 此时根结点已不满足大根堆的性质，堆被破坏。这时将堆顶元素向下调整使其继续保持大根堆的性质
 * <p>
 * 堆排序其实也是先使得局部是有序，然后一步步使得全局有序
 */
public class HeapSort {

    public void heapSort(int[] arr) {
        //首先构建堆
        for (int i = arr.length / 2 - 1; i >= 0; i--) {
            //调整堆
            adjustDown(arr, i, arr.length);
        }
        int j = arr.length - 1;
        //构建完堆后，我们将堆顶与堆底的数据交换
        //然后每一次只需要调整这个堆顶就好了，下层都是局部有序的。
        while (j > 0) {
            MySortUtil.swap(arr, 0, j);
            adjustDown(arr, 0, j);
            j--;
        }
    }

    //将当前节点下层到更深的层级（如果有必要） 调整的过程就是使得非叶子节点下沉的过程
    public void adjustDown(int[] arr, int i, int length) {
        //当前要调整的节点，
        int temp = arr[i];
        //largest不仅确定了最大的子节点的位置，也告诉了我们，当前节点需要下沉的方向。
        //要向lasrgest为跟节点的子树下沉。
        //largest = 2 * largest + 1 获取到子节点的右子树
        for (int largest = 2 * i + 1; largest < length; largest = 2 * largest + 1) {
            //找出最大的子节点
            //如果largest节点（左子节点）有兄弟节点（即右子节点 那么比较下哪个子节点大
            if (largest < length - 1 && arr[largest] < arr[largest + 1]) {
                largest++;
            }

            if (arr[largest] > temp) {
                //如果发现该节点小于子节点，那么直接将当前节点的值置为最大的子节点
                //为什么可以马上就确定该index的值呢？因为你要知道的是以该孩子的节点为跟节点的子树
                //已经是堆结构了，该孩子节点一定是这一层到任何叶节点的所有节点中最大的值，所以可以直接赋值。
                arr[i] = arr[largest];
                //i在这个循环里面，始终代表这当前调整的子树的根节点index.
                i = largest;
            } else {
                break;
            }

        }
        arr[i] = temp;
        //经过在指定子树不断向叶子节点遍历的过程中，i即是最后该节点需要下沉的位置
    }
}
